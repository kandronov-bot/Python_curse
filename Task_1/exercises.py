def list_to_pow(nums:list, pow:int):
    """ Возводит все элементы списка целых чисел в целую степень
    
    Аргументы:
        - nums:list - список целых чисел
        - pow:int - степень, в которую необходимо возвести числа
    
    Возвращает:
        - list целых чисел

    Указания: 
        - используйте map и lambda
        - авторское решение занимает 40 символов
    """
    #list - (то что надо преобразовать в список)
    #map - (функци применяемая к обьектам, элеменнты по которым происходит итерация, ещё, ...)
    #lambda - анонимная функция lambda элемент который подается в функцию: исполнения алгоритма к поданным данным 
    nums_pow = list(map(lambda x: x**pow, nums)) 
    return nums_pow


def naive_encoder(n):
    """ Вычисляет n + nn + nnn для данного n. Например,
        для n = 10 вычисляет 10 + 1010 + 101010
    
    Аргументы:
        - n:int - неотрицательное целое число

    Возвращает:
        - int

    Указания:
        - используйте преобразование типов int и str друг в друга
        - авторское решение занимает 40 символов
    """

    n = str(n)
    non = int(n) + int(n+n) + int(n+n+n)
    return non


def fibonacci_nth(n):
    """ Вычисляет n-е число Фибоначчи
    
    Аргументы:
        - n:int - натуральное число от 1 до 10**5
    
    Возвращает:
        - int

    Указания:
        - не нужно хранить в памяти всю последовательность чисел
        - используйте множественное присваивание, например: a, b = 1, 1
        - авторское решение занимает 6 строк
    """
    prev_n , next_n = 1, 1 # начальные значения
    for i in range(2,n): 
        if n == 1: 
            return prev_n
        elif n == 2:
            return next_n
        prev_n, next_n = next_n, next_n + prev_n # увеличение значения next_n
    return next_n

        



def clip_list(objl, a_min, a_max):
    """ Проверяет, что объекты списка objl находятся в диапазоне значений [a_min, a_max]
        Если элемент списка меньше a_min, то его значение меняется на a_min.
        Если элемент списка больше a_max, то его значение меняется на a_max.

    Аргументы:
        - objl:list - список объектов для которых определен оператор <
        - a_min - объект того же типа, что элементы списка objl
        - a_max - объект того же типа, что элементы списка objl, a_min <= a_max

    Возвращает:
        - list: список, элементы которого находятся в диапазоне значений [a_min, a_max]

    Указания:
        - Используйте функции min и max
        - способ 1:
            - используйте list comprehension
            - авторское решение занимает 48 символа
        - способ 2:
            - функцию map и lambda-функцию
            - авторское решение занимает 59 символа
    """
    objl_new = [a_min if x < a_min else a_max if x > a_max else x for x in objl] # почему не elif? 
    return objl_new


def input_to_list():
    """ Запрашивает список целых чисел через стандартный поток в формате
        "n1, n2, n3, ..., ni", i >= 0, и преобразует его в список целых чисел

    Аргументы: отсутствуют

    Возвращает:
        - list: список целых чисел

    Указания:
        - гарантируется, что вводятся корректные данные
        - обратите внимание на случаи, когда вход подается 0 и 1 число
        - используйте функцию input и метод split типа str
        - используйте оператор in для поиска по строке
        - авторское решение занимает 6 строк
    """
    input_str = input()
    if not input_str.strip():
        return []
    return [int(s) for s in input_str.split(",")]


def income_by_client(records):
    """ Подсчитывает поступления от каждого клиента по списку всех поступлений

    Аргументы:
        - records: список (list) кортежей (tuple). Каждый кортеж состоит из
                   двух элементов: (имя клиента: str, сумма: int). Например:
                   [('John', 100), ('Anna', 251), ('John', 50)]

    Возвращает:
        - dict: словарь, ключ которого есть имя клиента, а значение - сумма 
                поступлений от этого клиента. Например:
                {'John': 150, 'Anna': 251}

    Указания:
        - авторское решение занимает 7 строк
    """
    my_dict = {}
    for name,value in records:  # распаковываем кортежы в данном списке и получаем оттуда 2 переменные 
        my_dict[name] = my_dict.get(name, 0) + value # присваивание словарю по ключу значение функция get - получает значение по ключу если не существует ключа возвращяет 0 и прибавляет значение value
    return my_dict

    


def add_prefix(str_list, pref):
    """ Добавляет префикс к каждой строке из списка. Строки, которые уже начинаются
        с нужного префикса, не изменяются

    Аргументы:
        - str_list:list - список строк
        - pref:str - префикс, который необходимо добавить

    Возвращает:
        - list: копию исходного списка, содержаший модифицированные строки. Строки
                должны располагаться в том же порядке, что и в исходном списке

    Указания:
        - используйте метод startswith типа str
        - способ 1: 
            - используйте комбинацию функции map и lambda-функции
            - авторское решение занимает 85 символа
        - способ 2:
            - используйте list comprehension
            - авторское решение занимает 74 символа
    """
    return [s if s.startswith(pref) else pref + s for s in str_list]


def hide_secrets(recodrs):
    """ Возвращает копию списка строк recodrs, из которого удалены все строки,
        содержащие `secret` в любой комбинации строчных и заглавных символов
        (например, `sEcReT` не должен проходить фильтр)

    Аргументы:
        - recodrs:list - список строк

    Возвращает:
        - list: список строк, прошедших фильтрацию, в том же порядке, в каком
                они располагались в исходном списке

    Указания:
        - используйте встроенную функцию filter в комбинации с lambda-функцией
        - используйте метод casefold или метод lower класса str
        - авторское решение занимает 68 символа
    """
    # filter - filter(функция которая применяется для проверки, обьект к которому применяется итерация)
    # Работает фильтрует на false ?
    return list(filter(lambda s: "secret" not in s.casefold(), recodrs))
    


def is_same_type(objlist):
    """ Возвращает True, если все объекты списка являются объектами одного типа
        и False, если список содержит хотя бы два объекта разных типов.

    Аргументы:
        - objlist:list - список объектов

    Возвращает:
        - bool

    Указания:
        - используйте встроенную функцию type
        - авторское решение занимает 39 символов
    """
    if objlist:
        # The Python all() function returns true if all the elements of a given iterable (List, Dictionary, Tuple, set, etc.) are True otherwise it returns False. используется не только для вычисления типа элементов | numbers = [1, 2, 3, 4, 5]result = all(x > 0 for x in numbers)
        return all(type(objlist[0]) == type(x) for x in objlist)
    else:
        return True
 
    


def file_to_str_list(path):
    """ Возвращает содержимое текстового файла в виде списка строк.
        Каждая строка соответствует строке файла

    Аргументы:
        - path: полный путь до файла. Гарантируется, что файл существует

    Возвращает:
        - list: список строк файла

    Указания:
        - используйте функцию open, чтобы открыть файл
        - файловый объект - итерируемый. Итерирование происходит по строкам
        - авторское решение занимает 35 символов
    """
    f = open(path, "r", encoding = "utf-8") 
    text = []
    for line in f:
        text.append(line)

    f.close()
    return text
